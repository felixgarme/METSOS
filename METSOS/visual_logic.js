/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.8.0
 * Wed, 22 Oct 2025 07:01:34 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function isObjectWorthProcessing(obj) {
        return obj.type !== 'AmbientLight' && obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable && objName in _pGlob.objCache) {
            objFound = _pGlob.objCache[objName] || null;
        }
    
        if (objFound && objFound.name === objName) {
            return objFound;
        }
    
        if (appInstance.scene) {
            appInstance.scene.traverse(obj => {
                if (!objFound && isObjectWorthProcessing(obj) && (obj.name === objName)) {
                    objFound = obj;
                    if (pGlobAvailable) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
        }
        return objFound;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function generateUniqueName(name, isUniqueCb) {
        let uniqueName = name;
    
        if (isUniqueCb !== undefined) {
            while (!isUniqueCb(uniqueName)) {
                const r = uniqueName.match(/^(.*?)(\d+)$/);
                if (!r) {
                    uniqueName += '2';
                } else {
                    uniqueName = r[1] + (Number.parseInt(r[2], 10) + 1);
                }
            }
        }
    
        return uniqueName;
    }
        
    function generateUniqueObjectName(name) {
        return generateUniqueName(name, name => !Boolean(getObjectByName(name)));
    }

    return {
        getObjectByName, retrieveObjectNames, transformCoordsSpace, getSceneCoordSystem,
        generateUniqueObjectName,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    
    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["posGeneral"] = posGeneral;
this.procedures["ModoP1"] = ModoP1;
this.procedures["ModoP1off"] = ModoP1off;
this.procedures["zoneA"] = zoneA;
this.procedures["zoneB"] = zoneB;
this.procedures["vA1"] = vA1;
this.procedures["vA2"] = vA2;
this.procedures["disable"] = disable;
this.procedures["vA3"] = vA3;
this.procedures["vA4"] = vA4;
this.procedures["vA5"] = vA5;
this.procedures["vA6"] = vA6;
this.procedures["vA7"] = vA7;
this.procedures["continuarB"] = continuarB;
this.procedures["vB1"] = vB1;
this.procedures["vB2"] = vB2;
this.procedures["continuarC"] = continuarC;
this.procedures["zoneC"] = zoneC;

var PROC = {
    "posGeneral": posGeneral,
    "ModoP1": ModoP1,
    "ModoP1off": ModoP1off,
    "zoneA": zoneA,
    "zoneB": zoneB,
    "vA1": vA1,
    "vA2": vA2,
    "disable": disable,
    "vA3": vA3,
    "vA4": vA4,
    "vA5": vA5,
    "vA6": vA6,
    "vA7": vA7,
    "continuarB": continuarB,
    "vB1": vB1,
    "vB2": vB2,
    "continuarC": continuarC,
    "zoneC": zoneC,
};

var VARS = Object.defineProperties({}, {
    'A7una': { get: function() { return A7una; }, set: function(val) { A7una = val; } },
});

var A7una;

// setCameraParam puzzle
function setCameraParam(type, camSelector, param) {

    const camNames = PzLib.retrieveObjectNames(camSelector);

    camNames.forEach(function(camName) {
        if (!camName)
            return;

        var cam = PzLib.getObjectByName(camName);
        if (!cam || !cam.isCamera) return;

        if (!(cam.isPerspectiveCamera || cam.isOrthographicCamera)) {
            console.error('setCameraParam: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        let isSetFirstpersonParam = false;

        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
                isSetOrbitParam = true;
                break;
            case 'ENABLE_COLLISIONS':
                isSetFirstpersonParam = true;
                break;
        }

        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'ALLOW_CTRL_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam || isSetFirstpersonParam);

        if (isSetControlsParam) {
            if (!cam.controlSettings) {
                console.error('setCameraParam: The "' + camName +'" camera has no control settings assigned');
                return;
            } else if ((isSetOrbitParam && cam.controlSettings.type != 'ORBIT') ||
                    (isSetFirstpersonParam && cam.controlSettings.type != 'FIRST_PERSON')) {
                console.error('setCameraParam: Incompatible camera controls: ' + cam.controlSettings.type);
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (cam.isPerspectiveCamera) {
                    cam.fov = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (cam.isOrthographicCamera) {
                    cam.zoom = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                cam.controlSettings.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                cam.controlSettings.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                cam.controlSettings.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                cam.controlSettings.enableZoom = param;
                break;
            case 'ALLOW_CTRL_ZOOM':
                cam.controlSettings.enableCtrlZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                cam.controlSettings.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMinDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMaxDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMinZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMaxZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                cam.controlSettings.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                cam.controlSettings.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                cam.controlSettings.orbitEnableTurnover = param;
                break;
            case 'ENABLE_COLLISIONS':
                cam.controlSettings.enableCollisions = param;
                break;
            case 'CLIP_START':
                cam.near = param;
                cam.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                cam.far = param;
                cam.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

// autoRotateCamera puzzle
function autoRotateCamera(enabled, speed) {

    if (appInstance.controls && appInstance.controls instanceof v3d.OrbitControls) {
        appInstance.controls.autoRotate = enabled;
        appInstance.controls.autoRotateSpeed = speed;
    } else {
        console.error('autorotate camera: Wrong controls type');
    }
}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// zoomCamera puzzle
function zoomCamera(objSelector, duration, doSlot) {

    duration = Math.max(0, duration);

    const objNames = PzLib.retrieveObjectNames(objSelector);

    const zoomObjects = [];
    objNames.forEach(function(name) {
        const obj = PzLib.getObjectByName(name);
        if (obj) {
            zoomObjects.push(obj);
        }
    });

    if (!zoomObjects.length) {
        return;
    }

    const camera = appInstance.getCamera();

    const zoom = [camera.zoom]; // for orthographic camera only

    const pos = _pGlob.vec3Tmp, target = _pGlob.vec3Tmp2;
    v3d.CameraUtils.calcCameraZoomToObjectsParams(camera, zoomObjects,
            pos, target, zoom);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            if (camera.isOrthographicCamera) {
                appInstance.controls.tweenZoomTo(target, zoom[0],
                        duration, doSlot);
            } else {
                appInstance.controls.tween(pos, target, duration, doSlot);
            }
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(pos);
        }
        camera.position.copy(pos);
        camera.lookAt(target);
        camera.zoom = zoom[0];
        camera.updateProjectionMatrix();
        doSlot();
    }
}

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = PzLib.transformCoordsSpace(worldPos,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = PzLib.getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = PzLib.transformCoordsSpace(worldTarget,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = PzLib.getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// Describe this function...
function posGeneral() {
  tweenCamera('A', 'general', 1, function() {}, 1);
}

// Describe this function...
function ModoP1() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('' + '\n' +
  'if (window.LookOnlyControls) {window.LookOnlyControls.enable();}' + '\n' +
  '')))(appInstance, v3d, PL, VARS, PROC);

}

// Describe this function...
function ModoP1off() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('if (window.LookOnlyControls) {' + '\n' +
  '    window.LookOnlyControls.disable();' + '\n' +
  '}')))(appInstance, v3d, PL, VARS, PROC);

}

// addAnnotation and removeAnnotation puzzles
function handleAnnot(add, annot, objSelector, contents, id, name) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        // check if it already has an annotation and remove it
        for (var j = 0; j < obj.children.length; j++) {
            var child = obj.children[j];
            if (child.type == "Annotation") {
                // delete all childs of annotation
                child.traverse(function(child2) {
                    if (child2.isAnnotation)
                        child2.dispose();
                    });
                obj.remove(child);
            }
        }
        if (add) {
            var aObj = new v3d.Annotation(appInstance.container, annot, contents);
            aObj.name = PzLib.generateUniqueObjectName(name ? name : annot);
            aObj.fadeObscured = _pGlob.fadeAnnotations;
            if (id) {
                aObj.annotation.id = id;
                aObj.annotationDialog.id = id+'_dialog';
            }
            obj.add(aObj);
        }
    }
}

// Describe this function...
function zoneA() {
  autoRotateCamera(false, 3);
  tweenCamera('', 'ZoneA', 0.8, function() {}, 0);
  handleAnnot(true, 'Planta Molibdeno', 'ZoneA', '', 'zoneA', undefined);
  registerSetTimeout(1, function() {
    ModoP1();

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('// Para MOSTRAR' + '\n' +
    'if (typeof window.toggleBotonesVA === \'function\') {' + '\n' +
    '    window.toggleBotonesVA(true);' + '\n' +
    '}')))(appInstance, v3d, PL, VARS, PROC);

    vA1();
    registerSetTimeout(0.2, function() {});
  });
}

// Describe this function...
function zoneB() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('// Para MOSTRAR' + '\n' +
  'if (typeof window.toggleBotonesVA === \'function\') {' + '\n' +
  '    window.toggleBotonesVA(false);' + '\n' +
  '}')))(appInstance, v3d, PL, VARS, PROC);

  handleAnnot(true, 'Planta Molibdeno', 'ZoneB', '', 'zoneB', undefined);
  registerSetTimeout(1, function() {
    tweenCamera('', 'ZoneB', 0.8, function() {}, 0);
    registerSetTimeout(1, function() {
      ModoP1();

      Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('if (typeof window.toggleBotonesVB === \'function\') {' + '\n' +
      '    window.toggleBotonesVB(true);' + '\n' +
      '}')))(appInstance, v3d, PL, VARS, PROC);

      vB1();
    });
  });
}

// Describe this function...
function zoneC() {
  handleAnnot(true, 'Planta Molibdeno', 'ZoneB', '', 'zoneB', undefined);
}

// Describe this function...
function vA1() {
  disable();
  tweenCamera('', 'A1', 0.5, function() {}, 0);
  registerSetTimeout(0.7, function() {
    tweenCamera('A1', 'pCube13', 3, function() {}, 0);
  });
}

// outline puzzle
function outline(objSelector, doWhat) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
    var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        if (doWhat == "ENABLE") {
            if (outlineArray.indexOf(obj) == -1)
                outlineArray.push(obj);
        } else {
            var index = outlineArray.indexOf(obj);
            if (index > -1)
                outlineArray.splice(index, 1);
        }
    }
}

// Describe this function...
function vA2() {
  disable();
  tweenCamera('', 'A2', 0.5, function() {}, 0);
  registerSetTimeout(1, function() {
    tweenCamera('A2', 'polySurface1105', 3, function() {}, 0);
    outline('polySurface1105', 'ENABLE');
  });
}

// Describe this function...
function disable() {
  outline(['ALL_OBJECTS'], 'DISABLE');
}

// Describe this function...
function vA3() {
  disable();
  tweenCamera('', 'Cylinder2739', 0.5, function() {}, 0);
  registerSetTimeout(1, function() {
    tweenCamera('A3', 'Cylinder2739', 3, function() {}, 0);
    outline('Cylinder2739', 'ENABLE');
  });
}

// Describe this function...
function vA4() {
  disable();
  tweenCamera('', 'A4', 0.5, function() {}, 0);
  registerSetTimeout(1, function() {
    tweenCamera('A4', 'pCube133', 3, function() {}, 0);
    outline('pCube133', 'ENABLE');
  });
}

// Describe this function...
function vA5() {
  disable();
  tweenCamera('', 'A5', 0.5, function() {}, 0);
  registerSetTimeout(1, function() {
    tweenCamera('A5', 'pCube133.001', 3, function() {}, 0);
    outline('pCube133.001', 'ENABLE');
  });
  A7una = true;
}

// Describe this function...
function vA6() {
  disable();
  tweenCamera('', 'Cylinder2737', 0.5, function() {}, 0);
  registerSetTimeout(1, function() {
    tweenCamera('A6', 'Cylinder2737', 3, function() {}, 0);
    outline('Cylinder2737', 'ENABLE');
  });
  A7una = true;
}

// Describe this function...
function vA7() {
  disable();
  if (A7una) {
    tweenCamera('', 'A7.1', 0.5, function() {}, 0);
    registerSetTimeout(0.7, function() {
      tweenCamera('A7.1', 'pCube133.004', 3, function() {
        tweenCamera('', 'A7.2', 0.5, function() {}, 0);
        registerSetTimeout(0.7, function() {
          tweenCamera('A7.2', 'pCube133.004', 3, function() {
            tweenCamera('', 'A7', 0.5, function() {}, 0);
            registerSetTimeout(0.7, function() {
              tweenCamera('A7', 'pCube133.004', 3, function() {}, 0);
              outline('pCube133.004', 'ENABLE');

              Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('mostrarContinuar(); ' + '\n' +
              'habilitarContinuar();  ')))(appInstance, v3d, PL, VARS, PROC);

            });
          }, 0);
        });
      }, 0);
    });
    A7una = false;
  } else {
    tweenCamera('', 'A7', 0.5, function() {}, 0);
    registerSetTimeout(0.7, function() {
      tweenCamera('A7', 'pCube133.004', 3, function() {}, 0);
      outline('pCube133.004', 'ENABLE');
    });
  }
}

// Describe this function...
function continuarB() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'ocultarContinuar();  ')(appInstance, v3d, PL, VARS, PROC);

  outline(['ALL_OBJECTS'], 'DISABLE');
  ModoP1off();
  registerSetTimeout(0.5, function() {
    posGeneral();
    registerSetTimeout(1, function() {
      zoneB();
    });
  });
}

// Describe this function...
function vB1() {
  outline(['ALL_OBJECTS'], 'DISABLE');
  tweenCamera('B1', 'polySurface1145', 0.5, function() {}, 0);
  outline('polySurface1145', 'ENABLE');
}

// Describe this function...
function vB2() {
  outline(['ALL_OBJECTS'], 'DISABLE');
  tweenCamera('B2.1', 'B2.2', 1, function() {
    tweenCamera('B2.2', 'B2.3', 1, function() {
      tweenCamera('B2.3', 'B2.4', 1, function() {
        tweenCamera('B2.4', 'B2', 1, function() {
          tweenCamera('B2', 'pCube133.006', 1, function() {
            outline('pCube133.006', 'ENABLE');

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('mostrarContinuar2(); ' + '\n' +
            'habilitarContinuar2();  ')))(appInstance, v3d, PL, VARS, PROC);

          }, 0);
        }, 0);
      }, 0);
    }, 0);
  }, 0);
}

// Describe this function...
function continuarC() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'ocultarContinuar2();  ')(appInstance, v3d, PL, VARS, PROC);

  outline(['ALL_OBJECTS'], 'DISABLE');
  ModoP1off();
}



  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('window.app = app; ' + '\n' +
  'import("./imports.js");' + '\n' +
  '')))(appInstance, v3d, PL, VARS, PROC);

  posGeneral();

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'app.controls.enableRotate = false;')(appInstance, v3d, PL, VARS, PROC);

  setCameraParam('KEYBOARD_CONTROLS', 'Camera', false);
  setCameraParam('ALLOW_PANNING', 'Camera', false);
  registerSetTimeout(0.2, function() {
    autoRotateCamera(true, 1.5);
  });
  registerSetTimeout(1, function() {
    zoomCamera('general', 1, function() {});
  });



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
